# 2018第二次积分赛解题报告
## A - Let the Balloon Rise 
### describe 
	     Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges' favorite time is 
	     guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.

	    This year, they decide to leave this lovely job to you.
	Input
	    Input contains multiple test cases. Each test case starts with a number N (0 < N <= 1000) -- the total number of balloons 
	    distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.

	    A test case with N = 0 terminates the input and this test case is not to be processed.
	Output
	    For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a 
	    unique solution for each test case.
	Sample Input
	    5
	    green
	    red
	    blue
	    red
	    red
	    3
	    pink
	    orange
	    pink
	    0
	Sample Output
	    red
	    pink
### code
	//题目大意：输入N行颜色输出最多的颜色名称。
	用map存，key记录颜色名称，value记录次数。
```cpp 
#include<iostream>
#include<map>
#include<string>
#include<string.h>
#include<iterator>
using namespace std;

int main()
{
	int n;
	string color;
	int i;
	while (cin >> n && n != 0)
	{
		map<string, int> cnt;
		map<string, int>::iterator iter;
		for (i = 0; i < n; i++)
		{
			cin >> color;
			if (!cnt.count(color)) cnt[color] = 0;
			cnt[color]++;
		}
		string ans;
		int max = 0;
		for (iter = cnt.begin(); iter != cnt.end(); iter++)
		{q
	    1 2 10
	    0 0 0
	Sample Output
	    2
	    5
```	    
### code
	//题目大意：输入A，B，n，根据所给公式求出f(n)的值。
	n的范围太大，用公式从3算到n会超时间和内存，公式中f(n)的值是对7取模后的结果，所以f(n)值的范围为0~6,当f(i)=f(i-1)=1就会出现循环，所以找到周
	期，n对周期取模即可。
```cpp
#include <iostream>
using namespace std;

int f[10000];

int main()
{
	int A, B, n;
	f[1] = f[2] = 1;
	while (cin >> A >> B >> n && (A || B || n))
	{
		int i;
		for (i = 3; i<10000; i++)
		{
			f[i] = (A*f[i - 1] + B * f[i - 2]) % 7;
			if (f[i] == 1 && f[i - 1] == 1)
				break;
		}
		n = n % (i - 2);   //往后多算了两个，所以周期为i-2 
		f[0] = f[i - 2];
		cout << f[n] << endl;
	}
	return 0;
}	
```
## C - Elevator
### describe
	     The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers 
	     denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, 
	     and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.

	    For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on 
	    the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.
	Input
	    There are multiple test cases. Each case contains a positive integer N, followed by N positive numbers. All the numbers in 
	    the input are less than 100. A test case with N = 0 denotes the end of input. This test case is not to be processed.
	Output
	    Print the total time on a single line for each test case.
	Sample Input
	    1 2
	    3 2 3 1
	    0
	Sample Output
	    17
	    41
### code
	//题目大意：电梯从0层开始上升一层用6s，下降一层4s，到指定楼层会停5s，根据所给数据，算出时间。
```cpp
#include <iostream>
using namespace std;

int a[105];

int main()
{
	int n;
	int i;
	long long time;
	while (cin>>n&&n)
	{
		time = 0;
		for (i = 0; i < n; i++)
		{
			cin >> a[i];
			if (i == 0) time += a[i] * 6;
			else {
				if (a[i] > a[i - 1]) time += ((a[i] - a[i - 1]) * 6);
				else time += ((a[i - 1] - a[i]) * 4);
			}
			time += 5;
		}
		cout << time << endl;
	}
	return 0;
}
```
## D - u Calculate e
### describe
	     A simple mathematical formula for e is

		

	    where n is allowed to go to infinity. This can actually yield very accurate approximations of e using relatively small 
	    values of n.
	Output
	    Output the approximations of e generated by the above formula for the values of n from 0 to 9. The beginning of your output 
	    should appear similar to that shown below.
	Sample Output

	    n e
	    - -----------
	    0 1
	    1 2
	    2 2.5
	    3 2.666666667
	    4 2.708333333
### code
```cpp
#include<iostream>
#include<iomanip>
using namespace std;

int main()
{
	cout << "n e" << endl;
	cout << "- -----------" << endl;
	int i, j;
	double e = 2.5;
	double num = 2;
	cout << 0 << " " << 1 << endl;
	cout << 1 << " " << 2 << endl;
	cout << 2 << " " << 2.5 << endl;
	for (i = 3; i < 10; i++)
	{
		cout << i << " ";
		num *= i;
		e += (1 / num);
		cout << setiosflags(ios::fixed) << setprecision(9) << e << endl;
	}
	return 0;
}
```
## E - Digital Roots 
### describe
	     The digital root of a positive integer is found by summing the digits of the integer. If the resulting value is a single 
	     digit then that digit is the digital root. If the resulting value contains two or more digits, those digits are summed and 
	     the process is repeated. This is continued as long as necessary to obtain a single digit.

	    For example, consider the positive integer 24. Adding the 2 and the 4 yields a value of 6. Since 6 is a single digit, 6 is 
	    the digital root of 24. Now consider the positive integer 39. Adding the 3 and the 9 yields 12. Since 12 is not a single 
	    digit, the process must be repeated. Adding the 1 and the 2 yeilds 3, a single digit and also the digital root of 39.
	Input
	    The input file will contain a list of positive integers, one per line. The end of the input will be indicated by an integer 
	    value of zero.
	Output
	    For each integer in the input, output its digital root on a separate line of the output.
	Sample Input
	    24
	    39
	    0
	Sample Output
	    6
	    3
### code
	//题目没提整数的范围，用longlong WA了，说明超出了longlong，用字符串储存，一个数的数根等于这个数对9取模，取模为0时，数根为9.
```cpp
#include<iostream>
#include<iomanip>
#include<string>
#include<string.h>
using namespace std;

char num[1005];

int main()
{
	int len;
	int i;
	int sum;
	while (cin >> num)
	{
		sum = 0;
		if (num[0] == '0') break;
		len = strlen(num);
		for (i = 0; i < len; i++)
		{
			sum += (num[i] - '0');
		}
		sum %= 9;
		if (sum == 0) sum = 9;
		cout << sum << endl;
	}
	return 0;
}
```
## F - Uniform Generator 
### describe
     Computer simulations often require random numbers. One way to generate pseudo-random numbers is via a function of the form

    seed(x+1) = [seed(x) + STEP] % MOD

    where '%' is the modulus operator.

    Such a function will generate pseudo-random numbers (seed) between 0 and MOD-1. One problem with functions of this form is that they 
    will always generate the same pattern over and over. In order to minimize this effect, selecting the STEP and MOD values carefully 
    can result in a uniform distribution of all values between (and including) 0 and MOD-1.

    For example, if STEP = 3 and MOD = 5, the function will generate the series of pseudo-random numbers 0, 3, 1, 4, 2 in a repeating 
    cycle. In this example, all of the numbers between and including 0 and MOD-1 will be generated every MOD iterations of the function. 
    Note that by the nature of the function to generate the same seed(x+1) every time seed(x) occurs means that if a function will 
    generate 
    all the numbers between 0 and MOD-1, it will generate pseudo-random numbers uniformly with every MOD iterations.

    If STEP = 15 and MOD = 20, the function generates the series 0, 15, 10, 5 (or any other repeating series if the initial seed is 
    other than 0). This is a poor selection of STEP and MOD because no initial seed will generate all of the numbers from 0 and MOD-1.

    Your program will determine if choices of STEP and MOD will generate a uniform distribution of pseudo-random numbers.
Input
    Each line of input will contain a pair of integers for STEP and MOD in that order (1 <= STEP, MOD <= 100000).
Output
    For each line of input, your program should print the STEP value right- justified in columns 1 through 10, the MOD value right-
    justified in columns 11 through 20 and either "Good Choice" or "Bad Choice" left-justified starting in column 25. The "Good Choice" 
    message should be printed when the selection of STEP and MOD will generate all the numbers between and including 0 and MOD-1 when 
    MOD numbers are generated. Otherwise, your program should print the message "Bad Choice". After each output test set, your program 
    should print exactly one blank line.
Sample Input

    3 5
    15 20
    63923 99999

Sample Output

             3         5    Good Choice

            15        20    Bad Choice

         63923     99999    Good Choice
### code
	//题目大意：用所给公式求出一串随机数，看这串随机数分布均不均匀
	用公式求出随机数后排序看有没有和下标不同的数，也可以用计数的方法看有没有出现过大于一次的数，用printf输出便于控制格式。
```cpp
#include<iostream>
#include<cstdio>
#include<string.h>
#include<algorithm>
#include<cstdio>
using  namespace std;

int s[100005], a[100005];

int main()
{
	int step, mod;
	int i;
	while (cin >> step >> mod)
	{
		memset(a, 0, sizeof(a));
		s[0] = 0;
		for (i = 1; i < mod; i++)
		{
			s[i] = (s[i - 1] + step) % mod;
			a[s[i]]++;
		}
		bool flag = 1;
		for (i = 0; i < mod; i++)
		{
			if (a[i] > 1) {
				flag = 0;
				break;
			}
		}
		printf("%10d%10d", step, mod);
		if (flag) cout << "    Good Choice" << endl;
		else cout << "    Bad Choice" << endl;
		cout << endl;
	}
	return 0;
}
```
