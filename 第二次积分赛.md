# 2018第二次积分赛解题报告
## A - Let the Balloon Rise 
### describe 
	     Contest time again! How excited it is to see balloons floating around. But to tell you a secret, the judges' favorite time is 
	     guessing the most popular problem. When the contest is over, they will count the balloons of each color and find the result.

	    This year, they decide to leave this lovely job to you.
	Input
	    Input contains multiple test cases. Each test case starts with a number N (0 < N <= 1000) -- the total number of balloons 
	    distributed. The next N lines contain one color each. The color of a balloon is a string of up to 15 lower-case letters.

	    A test case with N = 0 terminates the input and this test case is not to be processed.
	Output
	    For each case, print the color of balloon for the most popular problem on a single line. It is guaranteed that there is a 
	    unique solution for each test case.
	Sample Input
	    5
	    green
	    red
	    blue
	    red
	    red
	    3
	    pink
	    orange
	    pink
	    0
	Sample Output
	    red
	    pink
### code
	//题目大意：输入N行颜色输出最多的颜色名称。
	用map存，key记录颜色名称，value记录次数。
```cpp 
#include<iostream>
#include<map>
#include<string>
#include<string.h>
#include<iterator>
using namespace std;

int main()
{
	int n;
	string color;
	int i;
	while (cin >> n && n != 0)
	{
		map<string, int> cnt;
		map<string, int>::iterator iter;
		for (i = 0; i < n; i++)
		{
			cin >> color;
			if (!cnt.count(color)) cnt[color] = 0;
			cnt[color]++;
		}
		string ans;
		int max = 0;
		for (iter = cnt.begin(); iter != cnt.end(); iter++)
		{
			if (iter->second > max)
			{
				max = iter->second;
				ans = iter->first;
			}
		}
		cout << ans << endl;
	}
	return 0;
}
```	    
### code
	//题目大意：输入A，B，n，根据所给公式求出f(n)的值。
	n的范围太大，用公式从3算到n会超时间和内存，公式中f(n)的值是对7取模后的结果，所以f(n)值的范围为0~6,当f(i)=f(i-1)=1就会出现循环，所以找到周
	期，n对周期取模即可。
```cpp
#include <iostream>
using namespace std;

int f[10000];

int main()
{
	int A, B, n;
	f[1] = f[2] = 1;
	while (cin >> A >> B >> n && (A || B || n))
	{
		int i;
		for (i = 3; i<10000; i++)
		{
			f[i] = (A*f[i - 1] + B * f[i - 2]) % 7;
			if (f[i] == 1 && f[i - 1] == 1)
				break;
		}
		n = n % (i - 2);   //往后多算了两个，所以周期为i-2 
		f[0] = f[i - 2];
		cout << f[n] << endl;
	}
	return 0;
}	
```
## C - Elevator
### describe
	     The highest building in our city has only one elevator. A request list is made up with N positive numbers. The numbers 
	     denote at which floors the elevator will stop, in specified order. It costs 6 seconds to move the elevator up one floor, 
	     and 4 seconds to move down one floor. The elevator will stay for 5 seconds at each stop.

	    For a given request list, you are to compute the total time spent to fulfill the requests on the list. The elevator is on 
	    the 0th floor at the beginning and does not have to return to the ground floor when the requests are fulfilled.
	Input
	    There are multiple test cases. Each case contains a positive integer N, followed by N positive numbers. All the numbers in 
	    the input are less than 100. A test case with N = 0 denotes the end of input. This test case is not to be processed.
	Output
	    Print the total time on a single line for each test case.
	Sample Input
	    1 2
	    3 2 3 1
	    0
	Sample Output
	    17
	    41
### code
	//题目大意：电梯从0层开始上升一层用6s，下降一层4s，到指定楼层会停5s，根据所给数据，算出时间。
```cpp
#include <iostream>
using namespace std;

int a[105];

int main()
{
	int n;
	int i;
	long long time;
	while (cin>>n&&n)
	{
		time = 0;
		for (i = 0; i < n; i++)
		{
			cin >> a[i];
			if (i == 0) time += a[i] * 6;
			else {
				if (a[i] > a[i - 1]) time += ((a[i] - a[i - 1]) * 6);
				else time += ((a[i - 1] - a[i]) * 4);
			}
			time += 5;
		}
		cout << time << endl;
	}
	return 0;
}
```
## D - u Calculate e
### describe
	     A simple mathematical formula for e is

		

	    where n is allowed to go to infinity. This can actually yield very accurate approximations of e using relatively small 
	    values of n.
	Output
	    Output the approximations of e generated by the above formula for the values of n from 0 to 9. The beginning of your output 
	    should appear similar to that shown below.
	Sample Output

	    n e
	    - -----------
	    0 1
	    1 2
	    2 2.5
	    3 2.666666667
	    4 2.708333333
### code
```cpp
#include<iostream>
#include<iomanip>
using namespace std;

int main()
{
	cout << "n e" << endl;
	cout << "- -----------" << endl;
	int i, j;
	double e = 2.5;
	double num = 2;
	cout << 0 << " " << 1 << endl;
	cout << 1 << " " << 2 << endl;
	cout << 2 << " " << 2.5 << endl;
	for (i = 3; i < 10; i++)
	{
		cout << i << " ";
		num *= i;
		e += (1 / num);
		cout << setiosflags(ios::fixed) << setprecision(9) << e << endl;
	}
	return 0;
}
```
## E - Digital Roots 
### describe
	     The digital root of a positive integer is found by summing the digits of the integer. If the resulting value is a single 
	     digit then that digit is the digital root. If the resulting value contains two or more digits, those digits are summed and 
	     the process is repeated. This is continued as long as necessary to obtain a single digit.

	    For example, consider the positive integer 24. Adding the 2 and the 4 yields a value of 6. Since 6 is a single digit, 6 is 
	    the digital root of 24. Now consider the positive integer 39. Adding the 3 and the 9 yields 12. Since 12 is not a single 
	    digit, the process must be repeated. Adding the 1 and the 2 yeilds 3, a single digit and also the digital root of 39.
	Input
	    The input file will contain a list of positive integers, one per line. The end of the input will be indicated by an integer 
	    value of zero.
	Output
	    For each integer in the input, output its digital root on a separate line of the output.
	Sample Input
	    24
	    39
	    0
	Sample Output
	    6
	    3
### code
	//题目没提整数的范围，用longlong WA了，说明超出了longlong，用字符串储存，一个数的数根等于这个数对9取模，取模为0时，数根为9.
```cpp
#include<iostream>
#include<iomanip>
#include<string>
#include<string.h>
using namespace std;

char num[1005];

int main()
{
	int len;
	int i;
	int sum;
	while (cin >> num)
	{
		sum = 0;
		if (num[0] == '0') break;
		len = strlen(num);
		for (i = 0; i < len; i++)
		{
			sum += (num[i] - '0');
		}
		sum %= 9;
		if (sum == 0) sum = 9;
		cout << sum << endl;
	}
	return 0;
}
```
## F - Uniform Generator 
### describe
     Computer simulations often require random numbers. One way to generate pseudo-random numbers is via a function of the form

    seed(x+1) = [seed(x) + STEP] % MOD

    where '%' is the modulus operator.

    Such a function will generate pseudo-random numbers (seed) between 0 and MOD-1. One problem with functions of this form is that they 
    will always generate the same pattern over and over. In order to minimize this effect, selecting the STEP and MOD values carefully 
    can result in a uniform distribution of all values between (and including) 0 and MOD-1.

    For example, if STEP = 3 and MOD = 5, the function will generate the series of pseudo-random numbers 0, 3, 1, 4, 2 in a repeating 
    cycle. In this example, all of the numbers between and including 0 and MOD-1 will be generated every MOD iterations of the function. 
    Note that by the nature of the function to generate the same seed(x+1) every time seed(x) occurs means that if a function will 
    generate 
    all the numbers between 0 and MOD-1, it will generate pseudo-random numbers uniformly with every MOD iterations.

    If STEP = 15 and MOD = 20, the function generates the series 0, 15, 10, 5 (or any other repeating series if the initial seed is 
    other than 0). This is a poor selection of STEP and MOD because no initial seed will generate all of the numbers from 0 and MOD-1.

    Your program will determine if choices of STEP and MOD will generate a uniform distribution of pseudo-random numbers.
Input
    Each line of input will contain a pair of integers for STEP and MOD in that order (1 <= STEP, MOD <= 100000).
Output
    For each line of input, your program should print the STEP value right- justified in columns 1 through 10, the MOD value right-
    justified in columns 11 through 20 and either "Good Choice" or "Bad Choice" left-justified starting in column 25. The "Good Choice" 
    message should be printed when the selection of STEP and MOD will generate all the numbers between and including 0 and MOD-1 when 
    MOD numbers are generated. Otherwise, your program should print the message "Bad Choice". After each output test set, your program 
    should print exactly one blank line.
Sample Input

    3 5
    15 20
    63923 99999

Sample Output

             3         5    Good Choice

            15        20    Bad Choice

         63923     99999    Good Choice
### code
	//题目大意：用所给公式求出一串随机数，看这串随机数分布均不均匀
	用公式求出随机数后排序看有没有和下标不同的数，也可以用计数的方法看有没有出现过大于一次的数，用printf输出便于控制格式。
```cpp
#include<iostream>
#include<cstdio>
#include<string.h>
#include<algorithm>
#include<cstdio>
using  namespace std;

int s[100005], a[100005];

int main()
{
	int step, mod;
	int i;
	while (cin >> step >> mod)
	{
		memset(a, 0, sizeof(a));
		s[0] = 0;
		for (i = 1; i < mod; i++)
		{
			s[i] = (s[i - 1] + step) % mod;
			a[s[i]]++;	//记录出现次数
		}
		bool flag = 1;
		for (i = 0; i < mod; i++)
		{
			if (a[i] > 1) {
				flag = 0;
				break;
			}
		}
		printf("%10d%10d", step, mod);
		if (flag) cout << "    Good Choice" << endl;
		else cout << "    Bad Choice" << endl;
		cout << endl;
	}
	return 0;
}
```
## ○ G - Safecracker
### describe
     === Op tech briefing, 2002/11/02 06:42 CST ===
    "The item is locked in a Klein safe behind a painting in the second-floor library. Klein safes are extremely rare; most of them, 
    along with Klein and his factory, were destroyed in World War II. Fortunately old Brumbaugh from research knew Klein's secrets and 
    wrote them down before he died. A Klein safe has two distinguishing features: a combination lock that uses letters instead of 
    numbers, and an engraved quotation on the door. A Klein quotation always contains between five and twelve distinct uppercase 
    letters, usually at the beginning of sentences, and mentions one or more numbers. Five of the uppercase letters form the combination 
    that opens the safe. By combining the digits from all the numbers in the appropriate way you get a numeric target. (The details of 
    constructing the target number are classified.) To find the combination you must select five letters v, w, x, y, and z that satisfy 
    the following equation, where each letter is replaced by its ordinal position in the alphabet (A=1, B=2, ..., Z=26). The combination 
    is then vwxyz. If there is more than one solution then the combination is the one that is lexicographically greatest, i.e., the one 
    that would appear last in a dictionary."

    v - w^2 + x^3 - y^4 + z^5 = target

    "For example, given target 1 and letter set ABCDEFGHIJKL, one possible solution is FIECB, since 6 - 9^2 + 5^3 - 3^4 + 2^5 = 1. There 
    are actually several solutions in this case, and the combination turns out to be LKEBA. Klein thought it was safe to encode the 
    combination within the engraving, because it could take months of effort to try all the possibilities even if you knew the secret. 
    But of course computers didn't exist then."

    === Op tech directive, computer division, 2002/11/02 12:30 CST ===

    "Develop a program to find Klein combinations in preparation for field deployment. Use standard test methodology as per departmental 
    regulations. Input consists of one or more lines containing a positive integer target less than twelve million, a space, then at 
    least five and at most twelve distinct uppercase letters. The last line will contain a target of zero and the letters END; this 
    signals the end of the input. For each line output the Klein combination, break ties with lexicographic order, or 'no solution' if 
    there is no correct combination. Use the exact format shown below."
Input
    1 ABCDEFGHIJKL
    11700519 ZAYEXIWOVU
    3072997 SOUGHT
    1234567 THEQUICKFROG
    0 END
Output
    LKEBA
    YOXUZ
    GHOST
    no solution
### code
	//题目大意：输入一个正整数和一串大写字母，找到其中的五个字母满足题中公式，如果有多组，输出字典顺序最大的。
	这个题和H题都是用回溯法写，不过这个题题目又臭又长，没有H题好理解。都是用dfs方法
```cpp
#include<iostream>
#include<cstdio>
#include<string.h>
#include<algorithm>
#include<cstdio>
#include<cmath>
using  namespace std;

char str[15];
char ans[10];
char ret[10];
bool visited[15];
long long target;
bool flag;
int len;

bool f(int v, int w, int x, int y, int z)
{
	if (v - w * w + x * x*x - y * y*y*y + z * z*z*z*z == target) return 1;
	return 0;
}
bool ff(char s[])
{
	return f(s[0] - 'A' + 1, s[1] - 'A' + 1, s[2] - 'A' + 1, s[3] - 'A' + 1, s[4] - 'A' + 1);
}
void dfs(int k)
{
	int i;
	if (k > 5) return;
	if (k == 5 && ff(ans))
	{
		ans[5] = '\0';
		flag = 0;
		strcpy(ret, ans);	//存放最后答案
//		cout << ans << endl;
	}
	else
	{
		for (i = 0; i < len; i++)
		{
			if (!visited[i])
			{
				visited[i] = 1;
				ans[k] = str[i];
				dfs(k+1);
				visited[i] = 0;
			}
		}
	}
}
int main()
{
	while (cin >> target >> str && (target || (strcmp(str, "END"))))
	{
		memset(visited, 0, sizeof(visited));
		memset(ans, 0, sizeof(ans));
		flag = 1;
		len = strlen(str);
		sort(str, str + len);	//对字符串排序，这样便于找到字典顺序的大的解
		dfs(0);
		if (flag) cout << "no solution" << endl;
		else
		{
			cout << ret << endl;
		}
	}
	return 0;
}
```
## ○ H - Prime Ring Problem
### describe
     A ring is compose of n circles as shown in diagram. Put natural number 1, 2, ..., n into each circle separately, and the sum of 
     numbers in two adjacent circles should be a prime.

    Note: the number of first circle should always be 1.


Input
    n (0 < n < 20).
Output
    The output format is shown as sample below. Each row represents a series of circle numbers in the ring beginning from 1 clockwisely 
    and anticlockwisely. The order of numbers must satisfy the above requirements. Print solutions in lexicographical order.

    You are to write a program that completes above process.

    Print a blank line after each case.
Sample Input
    6
    8
Sample Output
    Case 1:
    1 4 3 2 5 6
    1 6 5 2 3 4
    Case 2:
    1 2 3 8 5 6 7 4
    1 2 5 8 3 4 7 6
    1 4 7 6 5 8 3 2
    1 6 7 4 3 8 5 2
### code
	//题目大意：1~n组成一个环，环中相邻的两个数的和为素数。
	用dfs，从1开始逐渐往后找找到符合的就输出，像树一样每一个分支是一种可能性，深度搜索每一种可能，直到所以的节点被访问。（看了其他人的解题报告才
	知道可以这样搞）
```cpp
#include<iostream>
#include<cstdio>
#include<string.h>
#include<algorithm>
#include<cstdio>
#include<cmath>
using  namespace std;

bool prime[40];  
bool visited[25];
int a[25];
int n;

void isprime()   //素数打表，便于后面计算
{
	int i, j, k;
	prime[0] = prime[1] = 0;
	for (i = 2; i < 40; i++)
	{
		int flag = 1;
		k = sqrt(i);
		for (j = 2; j <= k; j++)
		{
			if (i%j == 0) {
				prime[i] = 0;
				flag = 0;
				break;
			}
		}
		if (flag) prime[i] = 1;
	}
}

void dfs(int k)
{
	if (k == n && prime[a[k] + 1])		//判断最后一个和第一个是否相同
	{
		cout << a[1];
		for (int i = 2; i <= n; i++)
		{
			cout << " " << a[i];
		}
		cout << endl;
	}
	else {
		for (int i = 2; i <= n; i++)	//尝试每一种可能
		{
			if (!visited[i])		//判断这个数是否已经用过
			{
				if (prime[i + a[k]])
				{
					visited[i] = 1;	//标记已用过的数
					a[k + 1] = i;
					dfs(k + 1);		//dfs下一个节点
					visited[i] = 0;	//恢复初始状态
				}
			}
		}
	}
}

int main()
{
	memset(prime, 0, sizeof(prime));
	isprime();
	int t = 1;
	while (cin >> n)
	{
		memset(a, 0, sizeof(a));
		memset(visited, 0, sizeof(visited));
		cout << "Case " << t++ << ":" << endl;
		a[1] = 1;
		dfs(1);			//从1开始，题目规定第一个数为1
		cout << endl;
	}
	return 0;
}
```
